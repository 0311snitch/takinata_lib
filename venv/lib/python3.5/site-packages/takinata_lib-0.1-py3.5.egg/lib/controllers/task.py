import lib.logger as logger
from datetime import *
from lib.exception import *
from lib.models.models import Task
from lib.storage.category import CategoryStorage
from lib.controllers.category import CategoryController
from lib.storage.project import *
from lib.storage.task import *
from lib.storage.user import *


class TaskController:
    log_tag = "TaskController"

    @classmethod
    def add_task(cls, username, password, project_id, category_id, name, desc, type, start_date, start_time, end_date,
                 end_time,
                 priority, parent_task_id=None, assosiated_task_id=None, to_deadline=None):
        """
        Creates a task in the selected column of the selected project with the specified time frame, tags, and priority
        tasks
        :param username:
        :param password:
        :param project_name:
        :param column_name:
        :param name:
        :param desc:
        :param first_date:
        :param second_date:
        :param tags:
        :param priority:
        :return:
        """
        log = logger.get_logger(TaskController.log_tag)
        user = UserStorage.get_user_by_name(username)
        if user.password == password:
            period = None
            if start_date == "" or end_date == "":
                pass
            else:
                start = datetime.strptime(start_date, '%m/%d/%Y')
                end = datetime.strptime(end_date, '%m/%d/%Y')
                if type == 2:
                    print(period)
                    period = (end - start).days
                if end < start:
                    log.error("EndDate is before StartDate")
                    raise EndBeforeStart
            if project_id != None:
                project = ProjectStorage.get_project_by_id(project_id)
                category = CategoryStorage.get_category_by_id(category_id)
                ProjectStorage.check_permission(user, project)
                task_names = TaskStorage.get_all_tasks(category_id)
            else:
                task_names = TaskStorage.get_all_user_task(UserStorage.get_user_by_name(username))
            have = False
            for i in task_names:
                if i.name == name:
                    have = True
            if not have:
                task = Task(name=name, desc=desc, start_date=start_date, start_time=start_time, end_date=end_date,
                            end_time=end_time, priority=priority, type=type, period=period, is_archive=0, is_subtask=0,
                            user_id=user.id,
                            category_id=category_id, project_id=project_id, parent_task_id=parent_task_id,
                            assosiated_task_id=assosiated_task_id)
                TaskStorage.add_task_to_db(task)
                return task
            else:
                log.error("Task with this name is already exist")
                raise TaskWithThisNameAlreadyExist(name)
        else:
            log.error("Incorrect password for {}".format(username))
            raise WrongPassword

    @classmethod
    def delete_task(cls, task_id):
        """
        Delete the specified task
        :param username:
        :param password:
        :param project_name:
        :param column_name:
        :param task_name:
        :return:
        """
        log = logger.get_logger(TaskController.log_tag)
        try:
            task = TaskStorage.get_task_by_id(task_id)
        except Exception:
            log.error("There is no task with this name")
            raise NoTask
        if task.is_subtask == 1:
            TaskStorage.delete_task_from_db(task)
        else:
            list = TaskStorage.get_all_subtasks(task)
            can = True
            for i in list:
                if i.is_archive != 1:
                    can = False
            if can:
                TaskStorage.delete_task_from_db(task)
            else:
                log.error("Can not to delete task, because task have some subtask")
                raise CanNotDeleteBecauseSubtasks

    @classmethod
    def get_all_users_task(cls, username, password):
        """
        Return all tasks, where user situated as executor or creator
        :return: task_list
        """
        cats = CategoryController.get_all_user_categories(username, password)
        task_list = []
        for category in cats:
            tasks = TaskController.show_tasks(username, password, category.id)
            task_list = task_list + tasks
        return task_list

    @classmethod
    def get_assosiated_task(cls, task):
        task_assosiate = TaskStorage.get_task_by_id(task.assosiated_task_id)
        return task_assosiate

    @classmethod
    def set_assosiated_task(cls, task, task_id):
        task.assosiated_task_id = task_id
        task2 = TaskStorage.get_task_by_id(task_id)
        if task2.is_archive == 1:
            raise CanNotAssosiateWithDoneTask
        elif task2.type == 2:
            raise CanNotAssosiateWithRegularTask
        else:
            task2.assosiated_task_id = task.id
            TaskStorage.save_assosiate(task)
            TaskStorage.save_assosiate(task2)

    @classmethod
    def cancel_task(cls, task):
        if task.assosiated_task_id != None:
            TaskStorage.cancel_task(task)
            TaskStorage.cancel_task(TaskStorage.get_task_by_id(task.assosiated_task_id))
        else:
            TaskStorage.cancel_task(task)

    @classmethod
    def show_tasks(cls, username, password, category_id):
        """
        Shows tasks for the specified column
        :param username:
        :param password:
        :param project_name:
        :param column_name:
        :return:
        """
        log = logger.get_logger(TaskController.log_tag)
        user = UserStorage.get_user_by_name(username)
        category = CategoryStorage.get_category_by_id(category_id)
        if user.password == password:
            tasks = TaskStorage.get_all_tasks(category_id)
            return tasks
        else:
            log.error("Incorrect password for {}".format(username))
            raise WrongPassword

    @classmethod
    def get_parent_task(cls, task):
        return TaskStorage.get_parent_task(task)

    @classmethod
    def get_all_subtask(cls, task):
        return TaskStorage.get_all_subtasks(task)

    @classmethod
    def new_set_subtask(cls, task1, task2):
        """
        Make task 1 a subtask of task 2
        :param username:
        :param password:
        :param project_name:
        :param column_name:
        :param task1:
        :param task2:
        :return:
        """
        log = logger.get_logger(TaskController.log_tag)
        task1 = TaskStorage.get_task_by_id(task1.id)
        task2 = TaskStorage.get_task_by_id(task2.id)
        if task1.is_subtask == 0:
            if task1.start_date > task2.start_date and task1.end_date < task2.end_date:
                if task1.priority > task2.priority:
                    raise SubtaskPriorityException
                else:
                    task1.is_subtask = 1
                    task1.parent_task_id = task2.id
                    task2.is_parent = 1
                    TaskStorage.save_subtask(task1)
                    TaskStorage.save_as_parent(task2)
            else:
                log.error("Subtask date error")
                raise SubtaskDateException
        else:
            log.error("Task is already subtask")
            raise AlreadySubtask

    @classmethod
    def set_subtask(cls, username, password, project_name, column_name, task1, task2):
        """
        Make task 1 a subtask of task 2
        :param username:
        :param password:
        :param project_name:
        :param column_name:
        :param task1:
        :param task2:
        :return:
        """
        log = logger.get_logger(TaskController.log_tag)
        user = UserStorage.get_user_by_name(username)
        project = ProjectStorage.get_project(project_name)
        if user.password == password:
            ProjectStorage.check_permission(user, project)
            task1 = TaskStorage.get_task(project_name, column_name, task1)
            task2 = TaskStorage.get_task(project_name, column_name, task2)
            if task1.is_subtask == '0':
                if task1.first_date > task2.first_date and task1.second_date < task2.second_date:
                    if task1.priority > task2.priority:
                        raise SubtaskPriorityException
                    else:
                        tasks = TaskStorage.get_all_subtasks(project_name, column_name, task2)
                        can = True
                        for i in tasks:
                            if task1 in tasks:
                                can = False
                        if can:
                            TaskStorage.set_subtask(task1, task2)
                            task1.is_subtask = 1
                            TaskStorage.save(task1)
                        else:
                            log.error("This task is already subtask")
                            raise AlreadySubtask
                else:
                    log.error("Subtask date error")
                    raise SubtaskDateException
            else:
                log.error("Task is already subtask")
                raise AlreadySubtask
        else:
            log.error("Incorrect password for {}".format(username))
            raise WrongPassword

    @classmethod
    def start_again(cls, task):
        new_start = datetime.today().date()
        new_end = new_start + timedelta(days=task.period)
        task.start_date = new_start.strftime('%m/%d/%Y')
        task.end_date = new_end.strftime('%m/%d/%Y')
        TaskStorage.refresh_task_date(task)

    @classmethod
    def edit(cls, type_of_edit, username, password, project_name, column_name, task_name, new_value):
        """
        Editing an attribute for a specified task
        :param type_of_edit:
        :param username:
        :param password:
        :param project_name:
        :param column_name:
        :param task_name:
        :param new_value:
        :return:
        """
        log = logger.get_logger(TaskController.log_tag)
        user = UserStorage.get_user_by_name(username)
        project = ProjectStorage.get_project(project_name)
        column = ColumnStorage.get_column(project_name, column_name)
        task = TaskStorage.get_task(project_name, column_name, task_name)
        if user.password == password:
            ProjectStorage.check_permission(user, project)
            if type_of_edit == 'name':
                task.name = new_value
            elif type_of_edit == 'description' or 'desc':
                task.desc = new_value
            elif type_of_edit == 'tags':
                task.tags = new_value
            elif type_of_edit == 'priority':
                try:
                    task.priority = int(new_value)
                except:
                    log.error("Type error")
                    raise TypeErro
            TaskStorage.save(task)
        else:
            raise WrongPassword

    @classmethod
    def check_notifications(self, username, password):
        """
        Checks tasks for how soon the deadline is and if there are tasks that have a deadline earlier than 20 days, then
        a notification is displayed
        :param username:
        :param password:
        :return:
        """
        user = UserStorage.get_user_by_name(username)
        red_list = []
        yellow_list = []
        green_list = []
        if user.password == password:
            tasks = TaskController.get_all_users_task(username, password)
            for task in tasks:
                if task.end_date != None and task.is_archive == 0:
                    task_date = datetime.strptime(task.end_date, '%m/%d/%Y')
                    to_make = (task_date - datetime.today()).days
                    task.to_deadline = to_make
                    if to_make <= 3:
                        red_list.append(task)
                    elif to_make <= 7 and to_make > 3:
                        yellow_list.append(task)
                    else:
                        green_list.append(task)
            return red_list, yellow_list, green_list
        else:
            raise WrongPassword
